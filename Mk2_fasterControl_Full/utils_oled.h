/**
 * @file utils_oled.h
 * @author Frédéric Metrich (frederic.metrich@live.fr)
 * @brief Some utility functions for OLED display
 * @version 0.1
 * @date 2024-11-10
 * 
 * @copyright Copyright (c) 2025
 * 
 */

#ifndef UTILS_OLED_H
#define UTILS_OLED_H

#include <Arduino.h>
#include <U8g2lib.h>

#include "type_traits.hpp"
#include "types.h"

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
// The pins for I2C are defined by the Wire-library.
// On an arduino UNO:       A4(SDA), A5(SCL)
#define OLED_RESET -1       /**< Reset pin # (or -1 if sharing Arduino reset pin) */
#define SCREEN_ADDRESS 0x3C /**< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32 */

/**
 * @brief This is a fake class in case there's no OLED display
 * 
 * When declaring a variable with the real OLED class, even it's not used, it is
 * loaded and partially initialized.
 * This leads to "break" the ADC measurement on old boards and
 * consumes memory on any board.
 * This is to avoid the use of "#ifdef" in the code to activate/deactivate
 * portions of code.
 * 
 * @ingroup OLEDDisplay
 */
class u8x8_fake
{
public:
  u8x8_fake(uint8_t) {}

  bool begin()
  {
    return true;
  }
  void clearDisplay() {}
  void noInverse() {}
  uint8_t getCols()
  {
    return 0;
  }
  uint8_t getRows()
  {
    return 0;
  }

  void setFont(const uint8_t *) {}
  void drawString(uint8_t, uint8_t, const char *) {}
  void drawGlyph(uint8_t, uint8_t, uint8_t) {}

  void drawTile(uint8_t, uint8_t, uint8_t, uint8_t *) {}
};

conditional< TYPE_OF_DISPLAY == DisplayType::OLED, U8X8_SSD1306_128X64_NONAME_HW_I2C, u8x8_fake >::type u8x8(/* reset=*/U8X8_PIN_NONE); /**< The OLED display object */

inline constexpr uint8_t LOGO_WIDTH{ 72 };  /**< The width of the object, in pixel */
inline constexpr uint8_t LOGO_HEIGHT{ 64 }; /**< The Height of the object, in pixel */

const unsigned char logo_xbm[] U8X8_PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xef, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbf, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0x9f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfb, 0xcf, 0x9f, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xf3,
  0xcf, 0x9f, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xdf, 0xdf, 0x3f,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xdf, 0xdf, 0x3f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xcf, 0xdf, 0xdf, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf,
  0x9f, 0xcf, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xdf, 0xcf, 0xcf,
  0xff, 0xff, 0xff, 0xff, 0xf3, 0xbf, 0x9f, 0xcf, 0xef, 0x7f, 0xfe, 0xff,
  0xff, 0xe7, 0x3f, 0xbf, 0xef, 0xe7, 0x3f, 0xff, 0xff, 0xff, 0xcf, 0x7f,
  0xbf, 0xef, 0xf7, 0x9f, 0xff, 0xff, 0xff, 0x1f, 0x7f, 0xbe, 0xef, 0xf3,
  0xc7, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xbe, 0xef, 0xfb, 0xe7, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3d, 0xe7, 0xf9, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xf9,
  0x79, 0xf7, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfb, 0xff, 0x7e,
  0xfe, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xcf, 0xff, 0xff, 0x9f, 0xff, 0xc7, 0xff, 0x3f, 0xf8, 0x9f,
  0xff, 0xff, 0xef, 0xff, 0xe0, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xef,
  0x3f, 0xfc, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff,
  0xff, 0x7f, 0xfc, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xe1,
  0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x43, 0x0b, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc7, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x00, 0xf0, 0xc7, 0x7f, 0x7e,
  0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xfe, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc7, 0xff, 0xa3, 0x45, 0xce, 0xe2, 0xff, 0xff, 0xff, 0xc7, 0xff, 0x3b,
  0x32, 0xb4, 0xfa, 0xff, 0xff, 0xff, 0xc7, 0xbf, 0x23, 0x62, 0x92, 0xe2,
  0xff, 0xff, 0xff, 0xc7, 0x9f, 0xab, 0x14, 0xa4, 0xfa, 0xff, 0xff, 0xff,
  0x07, 0x80, 0xf7, 0xeb, 0xcd, 0xe6, 0x07, 0x00, 0xe0, 0xc7, 0x8f, 0xff,
  0xff, 0xff, 0xff, 0xe7, 0x23, 0xfc, 0xc7, 0x9f, 0xe4, 0xff, 0xff, 0xff,
  0xcf, 0x33, 0xfc, 0xc7, 0x1f, 0x00, 0xfc, 0xff, 0xff, 0x8f, 0x99, 0xf9,
  0xc7, 0x3f, 0x3c, 0xf8, 0xff, 0xff, 0x9f, 0x99, 0xf1, 0xc7, 0x3f, 0xfc,
  0xf0, 0xff, 0xff, 0x3f, 0xcc, 0xf3, 0xc7, 0x3f, 0xfc, 0xf0, 0xff, 0xff,
  0x3f, 0xc4, 0xe7, 0xc7, 0x3f, 0xfc, 0xe1, 0xff, 0xff, 0x07, 0x00, 0xe0,
  0xc7, 0x3f, 0xfc, 0xe1, 0xff, 0xff, 0x07, 0x00, 0xe8, 0xc7, 0x3f, 0xfc,
  0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x3f, 0xfc, 0xf1, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x03, 0x00, 0xfc, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x3f, 0x3c, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00,
  0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x1c, 0xfe, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x3f, 0x7c, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x3f, 0x7c, 0xf8, 0xff, 0xff, 0xff, 0x18, 0x2b, 0x22, 0x3e, 0xfc,
  0xf8, 0xff, 0xff, 0xff, 0x6a, 0x6a, 0x73, 0x3e, 0xfc, 0xf0, 0xff, 0xff,
  0xff, 0xc8, 0x7a, 0x23, 0x3e, 0xfc, 0xf0, 0xff, 0xff, 0xff, 0x58, 0x6a,
  0x2b, 0x3e, 0xfc, 0xf1, 0xff, 0xff, 0xff, 0x97, 0x77, 0xeb, 0x3d, 0xfc,
  0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xe3, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x1f, 0xf8, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc,
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
}; /**< The xml object */

#if !defined(__DOXYGEN__)
inline uint8_t *get_tile_from_xbm(uint8_t, uint8_t, uint8_t, const unsigned char *) __attribute__((always_inline));
#endif

/**
 * @brief Get the tile from xbm object
 * 
 * @param tx Relative x position of the tile
 * @param ty Relative y position of the tile
 * @param xbm_byte_width Width of the xbm object
 * @param xbm The xbm object
 * @return uint8_t* 
 * 
 * @ingroup OLEDDisplay
 */
uint8_t *get_tile_from_xbm(uint8_t tx, uint8_t ty, uint8_t xbm_byte_width, const unsigned char *xbm)
{
  uint8_t d[8];
  const auto *p{ xbm + tx + xbm_byte_width * (ty << 3) };

  // Clear the tile buffer
  memset(d, 0, sizeof(d));

  for (uint8_t i = 0; i < 8; ++i)
  {
    uint8_t b = u8x8_pgm_read(p);
    for (uint8_t bit = 0; bit < 8; ++bit)
    {
      if (b & (1 << bit))
      {
        d[bit] |= (1 << i);
      }
    }
    p += xbm_byte_width;
  }
  return d;
}

/**
 * @brief Draw the xbm on the OLED display
 * 
 * @param _tx x position for drawing the xbm
 * @param _ty y position for drawing the xbm
 * @param xbm_width Width of the xbm
 * @param xbm_height Height of the xbm
 * @param xbm The xbm object
 * 
 * @ingroup OLEDDisplay
 */
void u8x8_draw_xbm(uint8_t _tx, uint8_t _ty, uint8_t xbm_width, uint8_t xbm_height, const unsigned char *xbm)
{
  for (uint8_t y = 0; y < (xbm_height >> 3); ++y)
  {
    for (uint8_t x = 0; x < (xbm_width >> 3); ++x)
    {
      const auto tile{ get_tile_from_xbm(x, y, xbm_width >> 3, xbm) };
      u8x8.drawTile(_tx + x, _ty + y, 1, tile);
    }
  }
}

/**
 * @brief Setup the OLED display
 * 
 * @ingroup OLEDDisplay
 */
void setupOLED()
{
  if constexpr (TYPE_OF_DISPLAY == DisplayType::OLED)
  {
    if (!u8x8.begin())
    {
      Serial.println(F("u8x8 allocation failed"));
    }

    // Clear the buffer
    u8x8.clearDisplay();

    u8x8.noInverse();

    u8x8_draw_xbm((u8x8.getCols() - (LOGO_WIDTH >> 3)) >> 1, (u8x8.getRows() - (LOGO_HEIGHT >> 3)) >> 1, LOGO_WIDTH, LOGO_HEIGHT, logo_xbm);
  }
}

/**
 * @brief Clear the display
 * 
 * @ingroup OLEDDisplay
 */
void clearDisplay()
{
  u8x8.clearDisplay();
}

/**
 * @brief Update the watchdog on the display
 * 
 * @ingroup OLEDDisplay
 */
void updateWatchdog()
{
  if constexpr (TYPE_OF_DISPLAY == DisplayType::OLED)
  {
    static bool watchdogState{ false };  // State of the blinking LED

    // Toggle the watchdog state
    watchdogState ^= true;

    if (watchdogState)
    {
      u8x8.setFont(u8x8_font_open_iconic_embedded_2x2);  // Change the font if needed
      u8x8.drawGlyph(0, 6, 70);                          // The symbol code
    }
    else
    {
      u8x8.drawString(0, 6, "  ");
    }
  }
}

/**
 * @brief Update the OLED display with the given value
 * 
 * @param value The value to display
 * 
 * @ingroup OLEDDisplay
 */
void updateOLED(uint16_t value)
{
  if constexpr (TYPE_OF_DISPLAY == DisplayType::OLED)
  {
    static char buffer[6];  // Buffer to hold the formatted string

    // Set the font and format the value as a float with max 3 decimal places and 4 digits wide
    u8x8.setFont(u8x8_font_inb33_3x6_n);
    dtostrf(value * 0.001f, 4, 3, buffer);
    u8x8.drawString(0, 0, buffer);

    // Set the font and draw the unit
    u8x8.setFont(u8x8_font_7x14B_1x2_r);
    u8x8.drawString(12, 6, "kWh");
  }
}

#endif /* UTILS_OLED_H */
