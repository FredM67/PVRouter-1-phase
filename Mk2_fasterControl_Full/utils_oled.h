/**
 * @file utils_oled.h
 * @author Frédéric Metrich (frederic.metrich@live.fr)
 * @brief Some utility functions for OLED display
 * @version 0.1
 * @date 2024-11-10
 * 
 * @copyright Copyright (c) 2024
 * 
 */

#ifndef UTILS_OLED_H
#define UTILS_OLED_H

#include <Arduino.h>
#include <U8g2lib.h>

#include "FastDivision.h"
#include "types.h"

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
// The pins for I2C are defined by the Wire-library.
// On an arduino UNO:       A4(SDA), A5(SCL)
// On an arduino MEGA 2560: 20(SDA), 21(SCL)
// On an arduino LEONARDO:   2(SDA),  3(SCL), ...
#define OLED_RESET -1        // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C  ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32

U8X8_SSD1306_128X64_NONAME_HW_I2C u8x8(/* reset=*/U8X8_PIN_NONE);

inline constexpr uint8_t LOGO_WIDTH{ 72 };
inline constexpr uint8_t LOGO_HEIGHT{ 64 };

const unsigned char logo_xbm[] U8X8_PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xef, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbf, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0x9f, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfb, 0xcf, 0x9f, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xf3,
  0xcf, 0x9f, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xdf, 0xdf, 0x3f,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xdf, 0xdf, 0x3f, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xcf, 0xdf, 0xdf, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf,
  0x9f, 0xcf, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xdf, 0xcf, 0xcf,
  0xff, 0xff, 0xff, 0xff, 0xf3, 0xbf, 0x9f, 0xcf, 0xef, 0x7f, 0xfe, 0xff,
  0xff, 0xe7, 0x3f, 0xbf, 0xef, 0xe7, 0x3f, 0xff, 0xff, 0xff, 0xcf, 0x7f,
  0xbf, 0xef, 0xf7, 0x9f, 0xff, 0xff, 0xff, 0x1f, 0x7f, 0xbe, 0xef, 0xf3,
  0xc7, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xbe, 0xef, 0xfb, 0xe7, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x3d, 0xe7, 0xf9, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xf9,
  0x79, 0xf7, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xfb, 0xff, 0x7e,
  0xfe, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff,
  0x1f, 0xff, 0xcf, 0xff, 0xff, 0x9f, 0xff, 0xc7, 0xff, 0x3f, 0xf8, 0x9f,
  0xff, 0xff, 0xef, 0xff, 0xe0, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xef,
  0x3f, 0xfc, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff,
  0xff, 0x7f, 0xfc, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xe1,
  0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x43, 0x0b, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc7, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x00, 0xf0, 0xc7, 0x7f, 0x7e,
  0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xfe, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xc7, 0xff, 0xa3, 0x45, 0xce, 0xe2, 0xff, 0xff, 0xff, 0xc7, 0xff, 0x3b,
  0x32, 0xb4, 0xfa, 0xff, 0xff, 0xff, 0xc7, 0xbf, 0x23, 0x62, 0x92, 0xe2,
  0xff, 0xff, 0xff, 0xc7, 0x9f, 0xab, 0x14, 0xa4, 0xfa, 0xff, 0xff, 0xff,
  0x07, 0x80, 0xf7, 0xeb, 0xcd, 0xe6, 0x07, 0x00, 0xe0, 0xc7, 0x8f, 0xff,
  0xff, 0xff, 0xff, 0xe7, 0x23, 0xfc, 0xc7, 0x9f, 0xe4, 0xff, 0xff, 0xff,
  0xcf, 0x33, 0xfc, 0xc7, 0x1f, 0x00, 0xfc, 0xff, 0xff, 0x8f, 0x99, 0xf9,
  0xc7, 0x3f, 0x3c, 0xf8, 0xff, 0xff, 0x9f, 0x99, 0xf1, 0xc7, 0x3f, 0xfc,
  0xf0, 0xff, 0xff, 0x3f, 0xcc, 0xf3, 0xc7, 0x3f, 0xfc, 0xf0, 0xff, 0xff,
  0x3f, 0xc4, 0xe7, 0xc7, 0x3f, 0xfc, 0xe1, 0xff, 0xff, 0x07, 0x00, 0xe0,
  0xc7, 0x3f, 0xfc, 0xe1, 0xff, 0xff, 0x07, 0x00, 0xe8, 0xc7, 0x3f, 0xfc,
  0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x3f, 0xfc, 0xf1, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x03, 0x00, 0xfc, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x3f, 0x3c, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00,
  0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x1c, 0xfe, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x3f, 0x7c, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x3f, 0x7c, 0xf8, 0xff, 0xff, 0xff, 0x18, 0x2b, 0x22, 0x3e, 0xfc,
  0xf8, 0xff, 0xff, 0xff, 0x6a, 0x6a, 0x73, 0x3e, 0xfc, 0xf0, 0xff, 0xff,
  0xff, 0xc8, 0x7a, 0x23, 0x3e, 0xfc, 0xf0, 0xff, 0xff, 0xff, 0x58, 0x6a,
  0x2b, 0x3e, 0xfc, 0xf1, 0xff, 0xff, 0xff, 0x97, 0x77, 0xeb, 0x3d, 0xfc,
  0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xe3, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0x1f, 0xf8, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc,
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

uint8_t *get_tile_from_xbm(uint8_t tx, uint8_t ty, uint8_t xbm_byte_width, const unsigned char *xbm)
{
  static uint8_t d[8];
  uint8_t mask = 1;
  uint8_t i;
  uint8_t b;
  const uint8_t *p = xbm;
  p += tx;
  p += xbm_byte_width * ty * 8;

  for (i = 0; i < 8; ++i)
    d[i] = 0;
  for (i = 0; i < 8; ++i)
  {
    b = u8x8_pgm_read(p);
    if (b & 1) d[0] |= mask;
    if (b & 2) d[1] |= mask;
    if (b & 4) d[2] |= mask;
    if (b & 8) d[3] |= mask;
    if (b & 16) d[4] |= mask;
    if (b & 32) d[5] |= mask;
    if (b & 64) d[6] |= mask;
    if (b & 128) d[7] |= mask;
    mask <<= 1;
    p += xbm_byte_width;
  }
  return d;
}

void u8x8_draw_xbm(uint8_t tx, uint8_t ty, uint8_t xbm_width, uint8_t xbm_height, const unsigned char *xbm)
{
  uint8_t *tile;
  for (uint8_t y = 0; y < (xbm_height >> 3); ++y)
  {
    for (uint8_t x = 0; x < (xbm_width >> 3); ++x)
    {
      tile = get_tile_from_xbm(x, y, xbm_width >> 3, xbm);
      u8x8.drawTile(tx + x, ty + y, 1, tile);
    }
  }
}

/**
 * @brief Setup the OLED display
 * 
 */
void setupOLED()
{
  if constexpr (TYPE_OF_DISPLAY == DisplayType::OLED)
  {
    if (!u8x8.begin())
    {
      Serial.println(F("u8x8 allocation failed"));
    }

    // Clear the buffer
    u8x8.clearDisplay();

    u8x8.noInverse();

    u8x8_draw_xbm((u8x8.getCols() - (LOGO_WIDTH >> 3)) >> 1, (u8x8.getRows() - (LOGO_HEIGHT >> 3)) >> 1, LOGO_WIDTH, LOGO_HEIGHT, logo_xbm);
  }
}

/**
 * @brief Clear the display
 * 
 */
void clearDisplay()
{
  u8x8.clearDisplay();
}

/**
 * @brief Update the watchdog on the display
 * 
 */
void updateWatchdog()
{
  if constexpr (TYPE_OF_DISPLAY == DisplayType::OLED)
  {
    static bool WATCHDOG_OLED{ false };  // State of the blinking LED

    // Blinking LED control
    WATCHDOG_OLED ^= true;

    if (WATCHDOG_OLED)
    {
      u8x8.setFont(u8x8_font_open_iconic_embedded_2x2);  // Change the font if needed
      u8x8.drawGlyph(0, 6, 70);                          // The symbol code
    }
    else
    {
      u8x8.drawString(0, 6, "  ");
    }
  }
}

/**
 * @brief Update the OLED display with the given value
 * 
 * @param value The value to display
 */
void updateOLED(uint16_t value)
{
  if constexpr (TYPE_OF_DISPLAY == DisplayType::OLED)
  {
    static char buffer[6];  // Buffer to hold the formatted string

    u8x8.setFont(u8x8_font_inb33_3x6_n);
    // Format the value as a float with max 3 decimal places and 4 digits wide
    dtostrf(value * 0.001F, 4, 3, buffer);
    u8x8.drawString(0, 0, buffer);

    u8x8.setFont(u8x8_font_7x14B_1x2_r);
    u8x8.drawString(12, 6, "kWh");
  }
}

#endif /* UTILS_OLED_H */
